#!/usr/bin/env node
// emacs mode -*-JavaScript-*-

var fs = require('fs'),
    getopt = require('node-getopt'),
    readline = require('readline'),
    http = require('http'),
    request = require('request'),
    Confirm = require('prompt-confirm'),
    colors = require('colors')

var bracery = require('..'),
    extend = bracery.ParseTree.extend

// parse command-line options
var opt = getopt.create([
  ['d' , 'defs=PATH+'       , 'load symbol definitions from JSON file(s)'],
  ['D' , 'text-defs=PATH+'  , 'load symbol definitions from Bracery plaintext file(s)'],
  ['o' , 'output=PATH'      , 'save symbol definitions to JSON file'],
  ['O' , 'output-text=PATH' , 'save symbol definitions to Bracery plaintext file'],
  ['s' , 'symbols=EXPR+'    , 'evaluate JSON symbol definitions from command line'],
  ['e' , 'eval=EXPR+'       , 'evaluate expression(s) text'],
  ['n' , 'num=NUMBER'       , 'number of randomized samples to output'],
  ['c' , 'config=JSON'      , 'specify config params (e.g. maxDepth, maxRecursion, maxLength, maxNodes, maxReps)'],
  ['V' , 'validate=EXPR+'   , 'validate and normalize text, without expanding'],
  ['t' , 'tree'             , 'show parse tree'],
  ['T' , 'compact-tree'     , 'like --tree, but compact'],
  ['a' , 'async'            , 'run asynchronously'],
  ['r' , 'repl'             , 'enter Read-Evaluate-Print Loop (REPL)'],
  ['S' , 'server=SOCKET'    , 'run as a web service'],
  ['C' , 'client=URL'       , 'run as client of web service'],
  ['m' , 'markov=FILE'      , 'run as Markov chain from template file'],
  ['q' , 'quiz=FILE'        , 'like --markov, but interactive'],
  ['v' , 'verbose'          , 'print logging info'],
  ['h' , 'help'             , 'display this help message']
])              // create Getopt instance
    .bindHelp()     // bind option 'help' to default action
    .parseSystem() // parse command line

var b = new bracery.Bracery()
var varVal = {}
function makeConfig() {
  var config = { vars: extend ({}, varVal) }
  if (opt.options.config)
    extend (config, JSON.parse (opt.options.config))
  return config
}

// logging
var before = {}, after = {}
if (opt.options.verbose) {
  before.all = console.warn.bind (console, 'before node,varval,depth:')
  after.all = console.warn.bind (console, 'after node,varval,depth,expansion:')
  if (opt.options.async || opt.options.client) {
    before.expand = console.warn.bind (console, 'before_expand node,varval,depth:')
    after.expand = console.warn.bind (console, 'after_expand node,varval,depth,rhs:')
  }
}

// simple client/server
var async = opt.options.async, symbolExpander
if (opt.options.client) {
  async = true
  symbolExpander = function (config) {
    return new Promise (function (resolve, reject) {
      request.post ({ url: opt.options.client,
                      json: true,
                      body: { text: '$' + config.node.name.toLowerCase() } },
                    function (err, res, body) {
                      if (err)
                        reject (err)
                      else
                        resolve (body.expansion.tree[0].rhs)
                    })
    })
  }
  console.warn ('resolving symbols via ' + opt.options.client)
}

if (opt.options.server) {
  function requestHandler (request, response) {
    var body = ''
    request.on ('data', function (chunk) { body += chunk.toString() })
    request.on ('end', function() {
      var text = JSON.parse(body).text
      console.warn ('> ' + text)
      b.expand (text,
                extend (makeConfig(),
                        { before: before,
                          after: after,
                          callback: function (expansion) {
                            console.warn ('< ' + expansion.text)
                            response.end (JSON.stringify ({ expansion: expansion }))
                          } }))
    })
  }
  
  var server = http.createServer (requestHandler)
  server.listen (opt.options.server, function (err) {
    if (err)
      throw err
  })
  console.warn ('listening on port ' + opt.options.server)
}

// main expand function: performs n expansions, synchronously or asynchronously,
// and outputs the result as text or a tree
var samples = parseInt(opt.options.num) || 1
var tree = opt.options.tree, compact = opt.options['compact-tree']
function expansionLogger (n, expansion) {
  if (opt.options.verbose)
    console.warn ('expansion' + (samples > 1 ? (' (' + (n+1) + '/' + samples + ')') : ''), expansion)
  console.log (tree || compact
               ? ((n ? ',' : '[')
                  + JSON.stringify(expansion,null,opt.options['compact-tree'] ? 0 : 2)
                  + (n == samples-1 ? ']' : ''))
               : expansion.text)
  if (expansion)
    varVal = expansion.vars
}

var printedSomething = false
function expand (expr) {
  for (var n = 0; n < samples; ++n) {
    var gotExpansion = expansionLogger.bind (null, n)
    var config = makeConfig()
    if (symbolExpander)
      config.expand = symbolExpander
    if (async)
      b.expand (expr, extend (config,
                              { before: before,
                                after: after,
                                callback: gotExpansion }))
    else
      gotExpansion (b.expand (expr, extend (config, { beforeSync: before,
                                                      afterSync: after })))
    printedSomething = true
  }
}

// load symbol definitions
var addedRules = false
function addRules (rules) {
  b.addRules (rules)
  if (Object.keys(rules).length)
    addedRules = true
}
function addRulesJSON (rulesJSON) {
  addRules (JSON.parse (rulesJSON))
}
function addRulesText (ruleText) {
  addRules (bracery.ParseTree.parseTextDefs (ruleText))
}
if (opt.options['text-defs'])
  opt.options['text-defs'].forEach (function (defsFile) {
    addRulesText (fs.readFileSync (defsFile).toString())
  })
if (opt.options.defs)
  opt.options.defs.forEach (function (symbolFile) {
    addRulesJSON (fs.readFileSync (symbolFile))
  })
if (opt.options.symbols)
  opt.options.symbols.forEach (addRulesJSON)

if (opt.options.output)
  fs.writeFileSync (opt.options.output, JSON.stringify (b.toJSON(), null, 2))

if (opt.options['output-text'])
  fs.writeFileSync (opt.options['output-text'], b.toText())

// print a log message about the symbol defs
var symbolNames = b.symbolNames()
if (symbolNames.length || opt.options.defs) {
  var nRules = symbolNames.reduce (function (sum, name) { return sum + b.getRules(name).length }, 0)
  console.warn('(' + bracery.ParseTree.nPlurals(symbolNames.length,'symbol')
               + ', ' + bracery.ParseTree.nPlurals(nRules,'rule')
               + ', initial symbol ' + bracery.ParseTree.symChar + b.getDefaultSymbol() + ')')
}

// validate expressions
if (opt.options.validate)
  opt.options.validate.forEach (function (expr) {
    console.log (tree
                 ? JSON.stringify (b.parse (expr), null, 2)
                 : (compact
                    ? JSON.stringify (b.parse (expr))
                    : b.normalize (expr)))
    printedSomething = true
  })

// evaluate any expressions
if (opt.options.eval)
  opt.options.eval.forEach (expand)

// run template Markov chain
if (opt.options.markov || opt.options.quiz) {
  function messageToString (message, config) {
    var color = (config && config.color) || {}
    return ((message.template.author
             ? ((color.author || colors.blue).call (colors, message.template.author) + ': ')
             : '')
            + (color.message || colors.yellow).call (colors, message.expansion.text))
  }
  function chainToString (chain, config) {
    return chain.map (function (message) { return messageToString (message, config) }).join('')
  }
  var templates = [opt.options.markov, opt.options.quiz]
      .reduce (function (temps, filename) {
        return temps.concat (filename ? bracery.Template.parseTemplateDefs (fs.readFileSync (filename).toString()) : [])
      }, [])
  var markovConfig = extend (makeConfig(),
                             { bracery: b,
                               templates: templates,
                               vars: varVal })
  if (opt.options.quiz)
    markovConfig.accept = function (message, thread) {
      if (thread)
        console.warn (chainToString (thread))
      console.warn (messageToString
                    (message,
                     { color: { author: colors.cyan,
                                message: colors.white } }))
      return new Confirm ('Accept?')
        .run()
    }

  bracery.Template.promiseMessageList (markovConfig)
    .then (function (chain) {
      console.log (chainToString (chain,
                                  { color: { author: colors.blue,
                                             message: colors.green } }))
    })
  printedSomething = true
}

// start a REPL
if (opt.options.repl) {
  console.warn ('enter Bracery text for expansion:')
  var rl = readline.createInterface ({ input: process.stdin,
                                       output: process.stdout })
  rl.on ('line', expand)
}

// expand something by default, or print an error message
if (!printedSomething && !opt.options.server && !opt.options.repl) {
  if (opt.argv.length)
    expand (opt.argv.join(' '))
  else {
    if (addedRules)
      expand()
  }
}

if (!printedSomething && !addedRules && !opt.options.server && !opt.options.repl)
  console.error ('please give me some Bracery text to expand')
